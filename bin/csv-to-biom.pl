#! /usr/bin/perl -w
use strict;
use Getopt::Long;
use JSON;
use Bio::SeqIO;
use POSIX qw(strftime);

my (
$OTUfastaFile,$OTUwbFile,$OTUclassifierFile,$diversityCSVfile,$diversityCSVheader,$geneTarget,
$workingDir,$totalToc,$mothurOutputDir,$chimeraBoolean,$assemblyMethod,$mappingMethod,
$isProtein,$outputFile,$libraryMetadataFile,$libraryMetadataDelim,$classifierCutoff,$diversityCol,
$VERBOSE,$prettyPrint,$OTUtree,$OTUproteinWbFile,
);

my $VERSION = '1.0';
my @options = (
	'a=s',	\$assemblyMethod,
	'c=s',	\$chimeraBoolean,
	'm=s',	\$mappingMethod,
	'of=s',	\$OTUfastaFile,
	'ow=s',	\$OTUwbFile,
	'pw=s',	\$OTUproteinWbFile,
	'oc=s',	\$OTUclassifierFile,
	'ot=s',	\$OTUtree,
	'cc=s',	\$classifierCutoff,
	'w=s',	\$workingDir,
	'dcsv=s',	\$diversityCSVfile,
	'dh=s',	\$diversityCSVheader,
	'g=s',	\$geneTarget,
	'p=s',	\$isProtein,
	'mo=s',	\$mothurOutputDir,
	'lm=s',	\$libraryMetadataFile,
	'ld=s',	\$libraryMetadataDelim,
	'o=s',	\$outputFile,
	'v=s',	\$VERBOSE,
	'pp=s',	\$prettyPrint
);
&GetOptions(@options);

$classifierCutoff		= 0.6 unless defined $classifierCutoff;
$VERBOSE			= 0 unless defined $VERBOSE;
$prettyPrint			= 0 unless defined $prettyPrint;
$libraryMetadataDelim		= "\t" unless defined $libraryMetadataDelim;

die <<EOF
Usage: $0 -a gsAssembler -c 0 -m bowtie2 -g cpn60 -dcsv /path/to/something.csv

Required: 
	-a  gsAssembler			what assembly approach did mPUMA use
	-m  bowtie2			what mapping technique did mPUMA use
	-c  0				boolean for whether mPUMA's C3 chimera check was used as a basis to EXCLUDE OTUs
	-w  /path/to/workingDir		this is the directory which was created by mPUMA and contains a libraries folder
	-g  cpn60			this is a simple label for what this experiment was trying to use as a target barcode
	-dcsv /path/to/abundances.csv	this is the actual CSV OTU abundances

Options / override-able:
	-of /path/to/OTU.fasta		this is the location of the OTU sequences to pull their sequences and include them from 
	-ow /path/to/OTU.wateredBLAST	this is the location of a wateredBLAST output file where the information from the best hit will be pulled
	-oc /path/to/OTU.classified	this is the location of an RDP classifier style output generated by analyzing the OTU.fasta
	-ot /path/to/OTU.newick		text file which contains a treefile you would like to include
	-cc $classifierCutoff				this is the cutoff to use when interpretting the classifier output and limiting the lineages which are stored as metadata
	-p  0				a boolean on whether the OTUs are based on protein sequences
	-mo /path/to/mothur/output	if the mothur output is specified then it can be included as metadata. script will look within this directory for rarefaction and stats info
	-lm /path/to/lib/metadata	additional metadata (e.g. experimental factors) which can be included
	-ld '\\t'			the delimiter used in the metadata file
	-o  /path/to/output.biom	where to write the output (default is STDOUT)
	-pp 0				boolean for whether to pretty print the JSON
EOF
unless(
	defined $assemblyMethod 
	and defined $chimeraBoolean
	and defined $mappingMethod
	and defined $geneTarget
	and defined $diversityCSVfile
);
# start building the object
my %obj;

# setup the header information
warn "Setting up header info" if $VERBOSE;
set_header_info(\%obj);

# add the assembly method
warn "Setting the assembly method" if $VERBOSE;
$obj{'mPUMA'}->{'assemblyMethod'} = $assemblyMethod;

# add the mapping method
warn "Setting mapping method" if $VERBOSE;
$obj{'mPUMA'}->{'mappingMethod'} = $mappingMethod;

# add the chimera boolean
warn "Setting the chimera usage" if $VERBOSE;
$obj{'mPUMA'}->{'C3chimeraUsage'} = $chimeraBoolean;

# add the gene target
warn "Setting the gene target" if $VERBOSE;
$obj{'mPUMA'}->{'geneTarget'} = $geneTarget;

######################### Library section

# need a generic hash to hold metadata and analysis info on the libraries
my %genericLibs;

######################### Add Generic metadata utility added here....
warn "Checking for additional outputs" if $VERBOSE;
parse_additional_library_metadata(\%genericLibs,$libraryMetadataFile,$libraryMetadataDelim) if defined $libraryMetadataFile;

# if mothur output exists add this as annotation to %genericLibs
warn "Checking for mothur outputs" if $VERBOSE;
parse_mothur_output(\%genericLibs,$mothurOutputDir) if defined $mothurOutputDir;


# add any other info about or derived from libraries here


######################### OTU section

# need a generic hash to hold metadata and analysis info on the OTU
my %genericOTUs;

## read OTU sequences
#warn "Checking for OTU sequence data" if $VERBOSE;
#parse_OTU_sequences(\%genericOTUs,$OTUfastaFile) if (defined $OTUfastaFile);
#
## read OTU classifier results
#warn "Checking for RDP-style classifier data" if $VERBOSE;
#parse_OTU_classifier(\%genericOTUs,$OTUclassifierFile,$classifierCutoff) if (defined $OTUclassifierFile);
#
## read wb results
#warn "Checking for wateredBLAST results" if $VERBOSE;
#parse_OTU_wateredBLAST(\%genericOTUs,$OTUwbFile) if (defined $OTUwbFile);
#parse_OTU_wateredBLAST(\%genericOTUs,$OTUproteinWbFile,'Protein') if (defined $OTUproteinWbFile);
#
#warn "Checking for OTU tree to include" if $VERBOSE;
#$obj{'OTUtree'} = read_tree($OTUtree) if (defined $OTUtree);

######################## Diversity section
my %abundanceData;

# this is where the actual OTU abundance info is sourced
read_diversity_csv_file($diversityCSVfile,\%abundanceData,\%genericOTUs,\%genericLibs);

#########################################################################
# All metadata and analysis for Libs and OTUs MUST precede this section #
#########################################################################

# Determine an Order for the OTUs and the Libraries
my @sortedOTU = sort {
	return $genericOTUs{$b}->{'analysis'}->{'prevalence'} <=> $genericOTUs{$a}->{'analysis'}->{'prevalence'}
} keys %genericOTUs;	# sorted by prevalence

my @sortedLibs = sort {
	return $a cmp $b
} keys %genericLibs; # sorted libs on their name


# figure out what the dimensions of the OTU table will be
my $numberOTU = @sortedOTU;
my $numberLibs = @sortedLibs;

# set the dimensionality of the shape key
warn "Setting the dimensionality" if $VERBOSE;
$obj{shape} = [$numberOTU,$numberLibs];

# add the rows and the metadata for the OTU
warn "Setting the OTU information" if $VERBOSE;
foreach my $OTU (@sortedOTU){
	my $O = $genericOTUs{$OTU};
	$O->{id} = $OTU;
	push(@{$obj{rows}},$O);
}

# add the columns
warn "Setting the Library information" if $VERBOSE;
foreach my $lib (@sortedLibs){
	my $L = $genericLibs{$lib};
	$L->{id} = $lib;
	push(@{$obj{columns}},$L);
}

# add the data itself
warn "Setting the abundance table" if $VERBOSE;
foreach my $OTU (@sortedOTU){
	my @vals;
	foreach my $lib (@sortedLibs){
		push(@vals,$abundanceData{$OTU}->{$lib});
	}
	push(@{$obj{data}},\@vals);
}

# print to a file if that is what was called for
open(STDOUT,">$outputFile") or die "Error opening $outputFile for writting: $!" 
	if defined $outputFile;

# convert to JSON
my $jsonOutput;

if ($prettyPrint){
	$jsonOutput = to_json(\%obj, { ascii => 1, pretty => 1 } );
}else{
	$jsonOutput = to_json(\%obj);
}

# print the object
print $jsonOutput;

### done
exit 0;

sub set_header_info {
	my $obj = shift;
	if (!defined $obj){
		my %new;
		$obj = \%new;
	}
	
	# simple header stuff...
	$obj->{'id'}			= '';
	$obj->{'format'}		= 'Biological Observation Matrix 0.9.1-dev';
	$obj->{'format_url'}		= 'http://biom-format.org/documentation/format_versions/biom-1.0.html';
	$obj->{'type'}			= 'OTU table';
	$obj->{'generated_by'}		= 'mPUMA';
	$obj->{'mPUMA'}->{'version'}	= $VERSION;
	$obj->{'date'}			= get_date();
	$obj->{'matrix_type'}		= 'dense';
	$obj->{'matrix_element_type'}	= 'float';
}

sub get_date{
        my $now = time();
        return strftime("%Y-%m-%dT%H:%M:%S", localtime($now));
}

sub parse_OTU_sequences {
	my $obj = shift;
	die "Error obj" unless defined $obj;
	my $file = shift;
	die "Error lost file" unless defined $file;
	my %OTU2Seq;	
	my $inio = Bio::SeqIO->new(-file => "<$file", -format => 'fasta');
	while(my $seq = $inio->next_seq()){
#		$OTU2Seq{$seq->display_id()} = $seq->seq();
		$obj->{$seq->display_id()}->{'metadata'}->{'sequence'} = $seq->seq();
	}
#	return \%OTU2Seq;
}

sub parse_OTU_classifier{
	my $obj = shift;
	die "Error lost obj" unless defined $obj;
	my $file = shift;
	die "Error lost file" unless defined $file;
	my $cutoff = shift;
	$cutoff = 0 unless defined $cutoff;
	open (FILE,"<$file") or die "Error opening $file for reading: $!";
	while(<FILE>){
		chomp $_;
		my ($id,$dummy,$k,$superkingdom,$kConf,$p,$phylum,$pConf,$c,$class,$conf,$o,$order,$oConf,$f,$family,$fConf,$g,$genus,$gConf) = split(/\t/,$_);
		die "Error with classifier line [$superkingdom,$phylum,$class,$order,$family,$genus]" 
			unless ((($superkingdom eq 'superkingdom')or($superkingdom eq 'kingdom'))
				and ($phylum eq 'phylum')
				and ($class eq 'class')
				and ($order eq 'order')
				and ($family eq 'family')
				and ($genus eq 'genus')
			);
		my $actualConf = 0;
		my @confidenceVals = ($kConf,$pConf,$conf,$oConf,$fConf,$gConf);
		my @labels = qw(k p c o f g);
		my @parts = ($k,$p,$c,$o,$f,$g);
		my @taxonomy;
		push(@taxonomy,'Root');
		for(my $i = 0; $i < @confidenceVals; $i++){
			if ($confidenceVals[$i] >= $cutoff){
				push(@taxonomy,join('__',$labels[$i],$parts[$i]));
				$actualConf = $confidenceVals[$i];
			}else{
				last;
			}
		}
#		$obj->{'taxonomy'}->{$id} = \@taxonomy;
#		$obj->{'confidence'}->{$id} = $actualConf;
		$obj->{$id}->{'analysis'}->{'RDP-style-classifer'}->{'taxonomy'} = \@taxonomy;
		$obj->{$id}->{'analysis'}->{'RDP-style-classifer'}->{'confidence'} = $actualConf;
	}
	close FILE or die "Error closing $file: $!";
}

sub parse_OTU_wateredBLAST {
	my $obj = shift;
	die "Error lost obj" unless defined $obj;
	my $file = shift;
	die "Error lost file" unless defined $file;
	my $string = shift;
	$string = 'Nucleotide' unless defined $string;

	open(FILE,"<$file") or die "Error opening $file for reading: $!";
	my %results;
	while(<FILE>){
		chomp $_;
		my (%hit,$id);
		($id,$hit{desc},$hit{percent},$hit{'length'},$hit{match},$hit{orientation}) = split(/\t/,$_);
		next unless ($hit{percent} >= 55); # winnow the garbage out this is based on observations of cpn60 data
		next if ((defined $results{$id})and($results{$id}->{percent} >= $hit{percent}));
		$results{$id} = \%hit;
	}
	close FILE or die "Error closing $file: $!";

	foreach my $id (keys %results){
#		$obj->{'nearest'.$string.'Match'}->{$id}		= $results{$id}->{match};
#		$obj->{'nearest'.$string.'Identity'}->{$id}		= $results{$id}->{percent};
#		$obj->{'nearest'.$string.'MatchLength'}->{$id}		= $results{$id}->{'length'};
#		$obj->{'nearest'.$string.'MatchOrientation'}->{$id}	= $results{$id}->{orientation};

		$obj->{$id}->{'analysis'}->{'wateredBLAST'}->{'nearest'.$string.'Match'}		= $results{$id}->{match};
		$obj->{$id}->{'analysis'}->{'wateredBLAST'}->{'nearest'.$string.'Identity'}		= $results{$id}->{percent};
		$obj->{$id}->{'analysis'}->{'wateredBLAST'}->{'nearest'.$string.'MatchLength'}		= $results{$id}->{'length'};
		$obj->{$id}->{'analysis'}->{'wateredBLAST'}->{'nearest'.$string.'MatchOrientation'}	= $results{$id}->{orientation};
	
	}
}


sub count_lines_in_text_file{
	my $file = shift;
	return 0 unless defined $file;
	open(FILE,"<$file") or die "Error opening $file for reading: $!";
	my $count = 0;
	while(<FILE>){
		$count++;
	}
	close FILE or die "Error closing $file: $!";
	return $count;
}


sub read_diversity_file {
	my $lib = shift;
	die "Error lost library name" unless defined $lib;
	my $file = shift;
	die "Error lost file" unless defined $file;
	my $col = shift;
	die "Error lost column" unless defined $col;
	my $abundance = shift;
	die "Error lost abundance" unless defined $abundance;
	my $genericOTU = shift;
	die "Error lost genericOTU" unless defined $genericOTU;

	open(FILE,"<$file") or die "Error opening $file for reading: $!";
	while(<FILE>){
		chomp $_;
		my @cols = split(/\t/,$_);
		my $id = $cols[0];
		die "Error multiple abundances defined for $id in $lib" if defined $abundance->{$id}->{$lib};
#		die "For $lib in $file and looking at $id in col $col = [",$cols[$col],"]";
		$abundance->{$id}->{$lib} = ($cols[$col] + 0); #### WARNING the + 0 or *1 here is important to convince the PERL interpreter that this is a numeric type and avoid putting quotes around it when outputting in JSON
		$genericOTU->{$id}->{'analysis'}->{'prevalence'}++;	# count its occurrance based on having been seen in this diversity file. N.B. this has no assurance that the abundance was > 0 just that there was a line for it...
#		$seenOTU->{$id}++;
	}
	close FILE or die "Error closing $file: $!";
}

sub read_diversity_csv_file{
	my $csvFile = shift;
	die "Error lost csv" unless defined $csvFile;
	my $abundance = shift;
	die "Error lost abundance" unless defined $abundance;
	my $genericOTU = shift;
	die "Error lost genericOTU" unless defined $genericOTU;
	my $genericLibs = shift;
	die "Error lost genericLibs" unless defined $genericLibs;
	

	open(FILE,"<$csvFile") or die "Error opening $csvFile: $!";
	my $header = <FILE>;
	chomp $header;
	my @libOrder = split(/\,/,$header);
	my $blah = shift @libOrder;
	my $numberOflibs = @libOrder;

	foreach my $lib (@libOrder){
		$genericLibs{$lib}->{'metadata'}->{'seenInOTUcsv'} = 1;
	}

	while(<FILE>){
		chomp $_;
		my @libAbundances = split(/\,/,$_);
		my $id = shift @libAbundances;
		for(my $i = 0; $i < @libAbundances; $i++){
			my $lib = $libOrder[$i];
			my $count = $libAbundances[$i];
			$abundance->{$id}->{$lib} = ($count + 0); #### WARNING the + 0 or *1 here is important to convince the PERL interpreter that this is a numeric type and avoid putting quotes around it when outputting in JSON
			$genericOTU->{$id}->{'analysis'}->{'prevalence'}++;	# count its occurrance based on having been seen in this diversity file. N.B. this has no assurance that the abundance was > 0 just that there was a line for it...
		}
	}
	close FILE or die "Error closing $csvFile: $!";
}


sub parse_mothur_output{
	my $obj = shift;
	die "Error lost object" unless defined $obj;
	my $dir = shift;
	die "Error lost file" unless defined $dir;
	opendir(DIR,$dir) or die "Error opening $dir: $!";
	while(my $file = readdir(DIR)){
		next if ($file =~ /^\./);
		if ($file eq 'freq_mothur.groups.summary'){
			# this is the file which contains the chief mothur stats
			parse_mothur_statsFile($obj,join('/',$dir,$file));
		}elsif($file =~/^mothur\.\d+\.logfile$/){
			# this is the log of the mothur run
			# in principle the version number could get recorded but to date that hasn't been implemented
		}elsif($file =~ /^freq_mothur\.(.+)\.rarefaction$/){
			# this is a library specific rarefaction
			parse_mothur_rarefaction($obj,$1,join('/',$dir,$file));
		}else{
			warn "Skipping file in the mothur directory $file" if $VERBOSE;
		}
	}
	closedir(DIR) or die "Error closing $dir: $!";
}

sub parse_mothur_rarefaction{
	my $obj = shift;
	die "Error lost object" unless defined $obj;
	my $lib = shift;
	die "Error lost library name" unless defined $lib;
	my $file = shift;
	die "Error lost file" unless defined $file;

	my @rareObj; # array of arrays, array of rows
	open(FILE,"<$file") or die "Error opening $file for reading: $!";

	# check the header
	my $header = <FILE>;
	chomp $header;
	die "Error header for rarefaction file ($file) is not as expected [$header]" 
		if ($header !~ /^numsampled\tNA\tlci\thci$/);

	# as expected
	while(<FILE>){
		chomp $_;
		my @elements = split(/\t/,$_);
		push(@rareObj,\@elements);
	}
	close FILE or die "Error closing $file: $!";

	$obj->{$lib}->{'analysis'}->{'mothur'}->{'rarefaction'} = \@rareObj;
}
	
sub parse_mothur_statsFile{
	my $obj = shift;
	die "Error lost object" unless defined $obj;
	my $file = shift;
	die "Error lost file" unless defined $file;
	open(FILE,"<$file") or die "Error opening $file for reading: $!";
	my $header = <FILE>;
	chomp $header;
	my @fields = split(/\t/,$header);
	my $label = shift @fields;
	my $group = shift @fields;
	while(<FILE>){
		chomp $_;
		my ($l,$g,@vals);
		($l,$g,@vals) = split(/\t/,$_);
		for(my $i = 0; $i < @vals;$i++){
#			$obj->{'mothur-'.$fields[$i]}->{$g} = $vals[$i];
			$obj->{$g}->{'analysis'}->{'mothur'}->{$fields[$i]} = $vals[$i];
		}
	}
	close FILE or die "Error closing $file: $!";
}

sub parse_additional_library_metadata {
	my $obj = shift;
	die "Error lost file" unless defined $obj;
        my $file = shift;
        die "Error lost file" unless defined $file;
        my $delim = shift;
        die "Error lost delimiter" unless defined $delim;

        open(FILE,'<',$file) or die "Error opening $file for reading: $!";
        my $header = <FILE>;
        chomp $header;
        my @fields = split(/$delim/,$header);
        my $idCol = shift @fields;

        while(<FILE>){
                chomp $_;
                my @values = split(/$delim/,$_);
                my $id = shift @values;
                for(my $i = 0; $i < @values;$i++){
                        die "Error no key for field $i @ line [$_]" unless defined $fields[$i];
			if ($fields[$i] =~ /^\*(.*)$/){
				# pick up on asterix as a notation that this is an experimental factor
				$obj->{$id}->{'metadata'}->{'experimentalFactors'}->{$1} = $values[$i];
			}else{
				$obj->{$id}->{'metadata'}->{$fields[$i]} = $values[$i];
			}
                }
        }
        close FILE or die "Error closing $file: $!";
}


sub read_tree {
	my $file = shift;
	die "Error lost file" unless defined $file;

	open(FILE,"<$file") or die "Error opening $file for reading: $!";
	my $tree;
	while(<FILE>){
		$tree .= $_;
	}
	close FILE or die "Error closing $file: $!";
	return $tree;
}




